{"version":3,"sources":["../src/core/embedding-provider.ts","../src/core/vector-store.ts","../src/core/memory-storage.ts","../src/core/memory-service.ts","../src/cam/cam-monitoring-service.ts","../src/index.ts"],"names":["OpenAI","Pool","uuidv4","connectionString"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Embedding Provider - OpenAI text-embedding-3-small\n * Generates vector embeddings for semantic search\n */\n\nimport OpenAI from 'openai';\nimport { EmbeddingProvider } from './types';\n\n/**\n * OpenAI Embedding Provider\n * Uses text-embedding-3-small (1536 dimensions, fast, cost-effective)\n */\nexport class OpenAIEmbeddingProvider implements EmbeddingProvider {\n  private client: OpenAI;\n  private model: string;\n  private dimension: number;\n\n  constructor(apiKey: string, model: string = 'text-embedding-3-small') {\n    this.client = new OpenAI({ apiKey });\n    this.model = model;\n    this.dimension = 1536; // text-embedding-3-small dimension\n  }\n\n  /**\n   * Generate embedding for text\n   */\n  async generateEmbedding(text: string): Promise<number[]> {\n    try {\n      const response = await this.client.embeddings.create({\n        model: this.model,\n        input: text,\n        encoding_format: 'float',\n      });\n\n      return response.data[0].embedding;\n    } catch (error: any) {\n      throw new Error(`Failed to generate embedding: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get embedding dimension\n   */\n  getDimension(): number {\n    return this.dimension;\n  }\n\n  /**\n   * Get model name\n   */\n  getModel(): string {\n    return this.model;\n  }\n}\n\n/**\n * In-Memory Embedding Provider (for testing)\n * Generates random embeddings - NOT for production\n */\nexport class MockEmbeddingProvider implements EmbeddingProvider {\n  private dimension: number;\n\n  constructor(dimension: number = 1536) {\n    this.dimension = dimension;\n  }\n\n  async generateEmbedding(text: string): Promise<number[]> {\n    // Generate deterministic random embedding based on text hash\n    const hash = this.simpleHash(text);\n    const embedding: number[] = [];\n    \n    for (let i = 0; i < this.dimension; i++) {\n      const seed = (hash + i) * 2654435761; // Knuth's multiplicative hash\n      embedding.push((Math.sin(seed) + 1) / 2); // Normalize to [0, 1]\n    }\n\n    // Normalize to unit vector\n    const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));\n    return embedding.map(val => val / magnitude);\n  }\n\n  getDimension(): number {\n    return this.dimension;\n  }\n\n  getModel(): string {\n    return 'mock-embedding';\n  }\n\n  private simpleHash(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n}\n","/**\n * Vector Store - pgvector integration for semantic search\n */\n\nimport { Pool } from 'pg';\nimport { VectorStore } from './types';\n\n/**\n * PostgreSQL + pgvector Vector Store\n */\nexport class PgVectorStore implements VectorStore {\n  private pool: Pool;\n  private tableName: string;\n  private dimension: number;\n  private initialized: boolean = false;\n\n  constructor(connectionString: string, tableName: string = 'wai_memory_vectors', dimension: number = 1536) {\n    this.pool = new Pool({ connectionString });\n    this.tableName = tableName;\n    this.dimension = dimension;\n  }\n\n  /**\n   * Initialize vector store (create table, enable pgvector)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Enable pgvector extension\n      await this.pool.query('CREATE EXTENSION IF NOT EXISTS vector');\n\n      // Create table\n      await this.pool.query(`\n        CREATE TABLE IF NOT EXISTS ${this.tableName} (\n          id VARCHAR(255) PRIMARY KEY,\n          embedding vector(${this.dimension}),\n          metadata JSONB,\n          created_at TIMESTAMP DEFAULT NOW()\n        )\n      `);\n\n      // Create index for similarity search (HNSW for fast approximate search)\n      await this.pool.query(`\n        CREATE INDEX IF NOT EXISTS ${this.tableName}_embedding_idx\n        ON ${this.tableName}\n        USING hnsw (embedding vector_cosine_ops)\n      `);\n\n      this.initialized = true;\n    } catch (error: any) {\n      throw new Error(`Failed to initialize vector store: ${error.message}`);\n    }\n  }\n\n  /**\n   * Store embedding\n   */\n  async store(id: string, embedding: number[], metadata?: Record<string, any>): Promise<void> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      await this.pool.query(\n        `INSERT INTO ${this.tableName} (id, embedding, metadata)\n         VALUES ($1, $2, $3)\n         ON CONFLICT (id) DO UPDATE\n         SET embedding = $2, metadata = $3`,\n        [id, JSON.stringify(embedding), metadata ? JSON.stringify(metadata) : null]\n      );\n    } catch (error: any) {\n      throw new Error(`Failed to store embedding: ${error.message}`);\n    }\n  }\n\n  /**\n   * Search similar embeddings using cosine similarity\n   */\n  async search(\n    queryEmbedding: number[],\n    limit: number = 10,\n    filters?: Record<string, any>\n  ): Promise<Array<{ id: string; similarity: number; metadata?: Record<string, any> }>> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      let query = `\n        SELECT \n          id,\n          1 - (embedding <=> $1::vector) as similarity,\n          metadata\n        FROM ${this.tableName}\n      `;\n\n      const params: any[] = [JSON.stringify(queryEmbedding)];\n\n      // Add metadata filters\n      if (filters && Object.keys(filters).length > 0) {\n        const conditions = Object.keys(filters).map((key, idx) => {\n          params.push(filters[key]);\n          return `metadata->>'${key}' = $${idx + 2}`;\n        });\n        query += ` WHERE ${conditions.join(' AND ')}`;\n      }\n\n      query += ` ORDER BY similarity DESC LIMIT $${params.length + 1}`;\n      params.push(limit);\n\n      const result = await this.pool.query(query, params);\n\n      return result.rows.map(row => ({\n        id: row.id,\n        similarity: parseFloat(row.similarity),\n        metadata: row.metadata || undefined,\n      }));\n    } catch (error: any) {\n      throw new Error(`Failed to search embeddings: ${error.message}`);\n    }\n  }\n\n  /**\n   * Delete embedding\n   */\n  async delete(id: string): Promise<void> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      await this.pool.query(`DELETE FROM ${this.tableName} WHERE id = $1`, [id]);\n    } catch (error: any) {\n      throw new Error(`Failed to delete embedding: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get statistics\n   */\n  async getStats(): Promise<{ count: number; dimension: number }> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      const result = await this.pool.query(`SELECT COUNT(*) as count FROM ${this.tableName}`);\n      return {\n        count: parseInt(result.rows[0].count),\n        dimension: this.dimension,\n      };\n    } catch (error: any) {\n      throw new Error(`Failed to get stats: ${error.message}`);\n    }\n  }\n\n  /**\n   * Close connection pool\n   */\n  async close(): Promise<void> {\n    await this.pool.end();\n  }\n}\n\n/**\n * In-Memory Vector Store (for testing)\n */\nexport class InMemoryVectorStore implements VectorStore {\n  private vectors: Map<string, { embedding: number[]; metadata?: Record<string, any> }> = new Map();\n  private dimension: number;\n\n  constructor(dimension: number = 1536) {\n    this.dimension = dimension;\n  }\n\n  async initialize(): Promise<void> {\n    // No-op for in-memory\n  }\n\n  async store(id: string, embedding: number[], metadata?: Record<string, any>): Promise<void> {\n    this.vectors.set(id, { embedding, metadata });\n  }\n\n  async search(\n    queryEmbedding: number[],\n    limit: number = 10,\n    filters?: Record<string, any>\n  ): Promise<Array<{ id: string; similarity: number; metadata?: Record<string, any> }>> {\n    const results: Array<{ id: string; similarity: number; metadata?: Record<string, any> }> = [];\n\n    for (const [id, { embedding, metadata }] of this.vectors.entries()) {\n      // Apply filters\n      if (filters && metadata) {\n        let match = true;\n        for (const [key, value] of Object.entries(filters)) {\n          if (metadata[key] !== value) {\n            match = false;\n            break;\n          }\n        }\n        if (!match) continue;\n      }\n\n      const similarity = this.cosineSimilarity(queryEmbedding, embedding);\n      results.push({ id, similarity, metadata });\n    }\n\n    return results\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, limit);\n  }\n\n  async delete(id: string): Promise<void> {\n    this.vectors.delete(id);\n  }\n\n  async getStats(): Promise<{ count: number; dimension: number }> {\n    return {\n      count: this.vectors.size,\n      dimension: this.dimension,\n    };\n  }\n\n  /**\n   * Calculate cosine similarity between two vectors\n   */\n  private cosineSimilarity(a: number[], b: number[]): number {\n    if (a.length !== b.length) {\n      throw new Error('Vectors must have the same dimension');\n    }\n\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n}\n","/**\n * Memory Storage - PostgreSQL-backed storage for memories\n */\n\nimport { Pool } from 'pg';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  MemoryStorage,\n  MemoryEntry,\n  MemorySearchQuery,\n  MemorySearchResult,\n  MemoryUpdate,\n  MemoryStats,\n  MemoryType,\n  VectorStore,\n  EmbeddingProvider,\n} from './types';\n\n/**\n * PostgreSQL Memory Storage\n */\nexport class PgMemoryStorage implements MemoryStorage {\n  private pool: Pool;\n  private tableName: string;\n  private vectorStore: VectorStore;\n  private embeddingProvider: EmbeddingProvider;\n  private initialized: boolean = false;\n\n  constructor(\n    connectionString: string,\n    vectorStore: VectorStore,\n    embeddingProvider: EmbeddingProvider,\n    tableName: string = 'wai_memories'\n  ) {\n    this.pool = new Pool({ connectionString });\n    this.vectorStore = vectorStore;\n    this.embeddingProvider = embeddingProvider;\n    this.tableName = tableName;\n  }\n\n  /**\n   * Initialize storage (create tables)\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      await this.pool.query(`\n        CREATE TABLE IF NOT EXISTS ${this.tableName} (\n          id VARCHAR(255) PRIMARY KEY,\n          type VARCHAR(50) NOT NULL,\n          content TEXT NOT NULL,\n          user_id VARCHAR(255),\n          session_id VARCHAR(255),\n          agent_id VARCHAR(255),\n          metadata JSONB,\n          tags TEXT[],\n          created_at TIMESTAMP NOT NULL DEFAULT NOW(),\n          updated_at TIMESTAMP NOT NULL DEFAULT NOW(),\n          access_count INTEGER DEFAULT 0,\n          last_accessed_at TIMESTAMP,\n          priority INTEGER DEFAULT 50,\n          ttl INTEGER\n        )\n      `);\n\n      // Create indexes\n      await this.pool.query(`\n        CREATE INDEX IF NOT EXISTS ${this.tableName}_type_idx ON ${this.tableName}(type);\n        CREATE INDEX IF NOT EXISTS ${this.tableName}_user_id_idx ON ${this.tableName}(user_id);\n        CREATE INDEX IF NOT EXISTS ${this.tableName}_session_id_idx ON ${this.tableName}(session_id);\n        CREATE INDEX IF NOT EXISTS ${this.tableName}_agent_id_idx ON ${this.tableName}(agent_id);\n        CREATE INDEX IF NOT EXISTS ${this.tableName}_tags_idx ON ${this.tableName} USING GIN(tags);\n        CREATE INDEX IF NOT EXISTS ${this.tableName}_created_at_idx ON ${this.tableName}(created_at DESC);\n      `);\n\n      // Initialize vector store\n      await this.vectorStore.initialize();\n\n      this.initialized = true;\n    } catch (error: any) {\n      throw new Error(`Failed to initialize memory storage: ${error.message}`);\n    }\n  }\n\n  /**\n   * Add new memory\n   */\n  async add(\n    memory: Omit<MemoryEntry, 'id' | 'createdAt' | 'updatedAt' | 'accessCount'>\n  ): Promise<MemoryEntry> {\n    if (!this.initialized) await this.initialize();\n\n    const id = uuidv4();\n    const now = new Date().toISOString();\n\n    try {\n      // Generate embedding\n      const embedding = await this.embeddingProvider.generateEmbedding(memory.content);\n\n      // Store in database\n      const result = await this.pool.query(\n        `INSERT INTO ${this.tableName} \n         (id, type, content, user_id, session_id, agent_id, metadata, tags, created_at, updated_at, access_count, priority, ttl)\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 0, $11, $12)\n         RETURNING *`,\n        [\n          id,\n          memory.type,\n          memory.content,\n          memory.userId || null,\n          memory.sessionId || null,\n          memory.agentId || null,\n          memory.metadata ? JSON.stringify(memory.metadata) : null,\n          memory.tags || null,\n          now,\n          now,\n          memory.priority || 50,\n          memory.ttl || null,\n        ]\n      );\n\n      // Store embedding in vector store\n      await this.vectorStore.store(id, embedding, {\n        type: memory.type,\n        userId: memory.userId,\n        sessionId: memory.sessionId,\n        agentId: memory.agentId,\n      });\n\n      return this.rowToMemoryEntry(result.rows[0], embedding);\n    } catch (error: any) {\n      throw new Error(`Failed to add memory: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get memory by ID\n   */\n  async get(id: string): Promise<MemoryEntry | null> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      const result = await this.pool.query(\n        `SELECT * FROM ${this.tableName} WHERE id = $1`,\n        [id]\n      );\n\n      if (result.rows.length === 0) {\n        return null;\n      }\n\n      // Update access tracking\n      await this.pool.query(\n        `UPDATE ${this.tableName}\n         SET access_count = access_count + 1, last_accessed_at = $1\n         WHERE id = $2`,\n        [new Date().toISOString(), id]\n      );\n\n      return this.rowToMemoryEntry(result.rows[0]);\n    } catch (error: any) {\n      throw new Error(`Failed to get memory: ${error.message}`);\n    }\n  }\n\n  /**\n   * Update memory\n   */\n  async update(id: string, updates: MemoryUpdate): Promise<MemoryEntry> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      const now = new Date().toISOString();\n      const setClauses: string[] = ['updated_at = $1'];\n      const values: any[] = [now];\n      let paramIndex = 2;\n\n      if (updates.content !== undefined) {\n        setClauses.push(`content = $${paramIndex++}`);\n        values.push(updates.content);\n\n        // Regenerate embedding if content changed\n        const embedding = await this.embeddingProvider.generateEmbedding(updates.content);\n        await this.vectorStore.store(id, embedding);\n      }\n\n      if (updates.metadata !== undefined) {\n        setClauses.push(`metadata = $${paramIndex++}`);\n        values.push(JSON.stringify(updates.metadata));\n      }\n\n      if (updates.tags !== undefined) {\n        setClauses.push(`tags = $${paramIndex++}`);\n        values.push(updates.tags);\n      }\n\n      if (updates.priority !== undefined) {\n        setClauses.push(`priority = $${paramIndex++}`);\n        values.push(updates.priority);\n      }\n\n      if (updates.ttl !== undefined) {\n        setClauses.push(`ttl = $${paramIndex++}`);\n        values.push(updates.ttl);\n      }\n\n      values.push(id);\n\n      const result = await this.pool.query(\n        `UPDATE ${this.tableName}\n         SET ${setClauses.join(', ')}\n         WHERE id = $${paramIndex}\n         RETURNING *`,\n        values\n      );\n\n      if (result.rows.length === 0) {\n        throw new Error(`Memory not found: ${id}`);\n      }\n\n      return this.rowToMemoryEntry(result.rows[0]);\n    } catch (error: any) {\n      throw new Error(`Failed to update memory: ${error.message}`);\n    }\n  }\n\n  /**\n   * Delete memory\n   */\n  async delete(id: string): Promise<boolean> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      const result = await this.pool.query(\n        `DELETE FROM ${this.tableName} WHERE id = $1`,\n        [id]\n      );\n\n      await this.vectorStore.delete(id);\n\n      return result.rowCount !== null && result.rowCount > 0;\n    } catch (error: any) {\n      throw new Error(`Failed to delete memory: ${error.message}`);\n    }\n  }\n\n  /**\n   * Search memories using semantic search\n   */\n  async search(query: MemorySearchQuery): Promise<MemorySearchResult[]> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      // Generate query embedding\n      const queryEmbedding = await this.embeddingProvider.generateEmbedding(query.query);\n\n      // Build filters for vector search\n      const vectorFilters: Record<string, any> = {};\n      if (query.type) vectorFilters.type = query.type;\n      if (query.userId) vectorFilters.userId = query.userId;\n      if (query.sessionId) vectorFilters.sessionId = query.sessionId;\n      if (query.agentId) vectorFilters.agentId = query.agentId;\n\n      // Search vector store\n      const vectorResults = await this.vectorStore.search(\n        queryEmbedding,\n        query.limit || 10,\n        vectorFilters\n      );\n\n      // Fetch full memory entries\n      const memories: MemorySearchResult[] = [];\n\n      for (const vectorResult of vectorResults) {\n        if (query.minSimilarity && vectorResult.similarity < query.minSimilarity) {\n          continue;\n        }\n\n        const memory = await this.get(vectorResult.id);\n        if (!memory) continue;\n\n        // Apply tag filters\n        if (query.tags && query.tags.length > 0) {\n          const hasAllTags = query.tags.every(tag => memory.tags?.includes(tag));\n          if (!hasAllTags) continue;\n        }\n\n        // Calculate relevance score (similarity + priority + recency)\n        const daysSinceCreation = (Date.now() - new Date(memory.createdAt).getTime()) / (1000 * 60 * 60 * 24);\n        const recencyScore = Math.max(0, 1 - (daysSinceCreation / 365)); // Decay over 1 year\n        const priorityScore = (memory.priority || 50) / 100;\n        const relevance = vectorResult.similarity * 0.6 + priorityScore * 0.2 + recencyScore * 0.2;\n\n        memories.push({\n          memory,\n          similarity: vectorResult.similarity,\n          relevance,\n        });\n      }\n\n      // Sort by relevance\n      return memories.sort((a, b) => b.relevance - a.relevance);\n    } catch (error: any) {\n      throw new Error(`Failed to search memories: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get all memories with filters\n   */\n  async getAll(filters?: {\n    type?: MemoryType;\n    userId?: string;\n    sessionId?: string;\n    agentId?: string;\n  }): Promise<MemoryEntry[]> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      let query = `SELECT * FROM ${this.tableName}`;\n      const conditions: string[] = [];\n      const values: any[] = [];\n      let paramIndex = 1;\n\n      if (filters?.type) {\n        conditions.push(`type = $${paramIndex++}`);\n        values.push(filters.type);\n      }\n\n      if (filters?.userId) {\n        conditions.push(`user_id = $${paramIndex++}`);\n        values.push(filters.userId);\n      }\n\n      if (filters?.sessionId) {\n        conditions.push(`session_id = $${paramIndex++}`);\n        values.push(filters.sessionId);\n      }\n\n      if (filters?.agentId) {\n        conditions.push(`agent_id = $${paramIndex++}`);\n        values.push(filters.agentId);\n      }\n\n      if (conditions.length > 0) {\n        query += ` WHERE ${conditions.join(' AND ')}`;\n      }\n\n      query += ` ORDER BY created_at DESC`;\n\n      const result = await this.pool.query(query, values);\n\n      return result.rows.map(row => this.rowToMemoryEntry(row));\n    } catch (error: any) {\n      throw new Error(`Failed to get all memories: ${error.message}`);\n    }\n  }\n\n  /**\n   * Cleanup expired memories (TTL)\n   */\n  async cleanup(): Promise<number> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      const result = await this.pool.query(\n        `DELETE FROM ${this.tableName}\n         WHERE ttl IS NOT NULL\n         AND EXTRACT(EPOCH FROM (NOW() - created_at)) > ttl\n         RETURNING id`\n      );\n\n      // Delete from vector store\n      for (const row of result.rows) {\n        await this.vectorStore.delete(row.id);\n      }\n\n      return result.rowCount || 0;\n    } catch (error: any) {\n      throw new Error(`Failed to cleanup memories: ${error.message}`);\n    }\n  }\n\n  /**\n   * Get statistics\n   */\n  async getStats(): Promise<MemoryStats> {\n    if (!this.initialized) await this.initialize();\n\n    try {\n      const totalResult = await this.pool.query(\n        `SELECT COUNT(*) as total FROM ${this.tableName}`\n      );\n\n      const typeResult = await this.pool.query(\n        `SELECT type, COUNT(*) as count FROM ${this.tableName} GROUP BY type`\n      );\n\n      const accessResult = await this.pool.query(\n        `SELECT AVG(access_count) as avg_access FROM ${this.tableName}`\n      );\n\n      const timestampResult = await this.pool.query(\n        `SELECT MIN(created_at) as oldest, MAX(created_at) as newest FROM ${this.tableName}`\n      );\n\n      const vectorStats = await this.vectorStore.getStats();\n\n      const memoryByType: Record<MemoryType, number> = {\n        user: 0,\n        session: 0,\n        agent: 0,\n        entity: 0,\n      };\n\n      for (const row of typeResult.rows) {\n        memoryByType[row.type as MemoryType] = parseInt(row.count);\n      }\n\n      return {\n        totalMemories: parseInt(totalResult.rows[0].total),\n        memoryByType,\n        totalEmbeddings: vectorStats.count,\n        averageAccessCount: parseFloat(accessResult.rows[0].avg_access) || 0,\n        oldestMemory: timestampResult.rows[0].oldest?.toISOString(),\n        newestMemory: timestampResult.rows[0].newest?.toISOString(),\n      };\n    } catch (error: any) {\n      throw new Error(`Failed to get stats: ${error.message}`);\n    }\n  }\n\n  /**\n   * Convert database row to MemoryEntry\n   */\n  private rowToMemoryEntry(row: any, embedding?: number[]): MemoryEntry {\n    return {\n      id: row.id,\n      type: row.type,\n      content: row.content,\n      embedding,\n      userId: row.user_id || undefined,\n      sessionId: row.session_id || undefined,\n      agentId: row.agent_id || undefined,\n      metadata: row.metadata || undefined,\n      tags: row.tags || undefined,\n      createdAt: row.created_at.toISOString(),\n      updatedAt: row.updated_at.toISOString(),\n      accessCount: row.access_count,\n      lastAccessedAt: row.last_accessed_at?.toISOString(),\n      priority: row.priority,\n      ttl: row.ttl,\n    };\n  }\n\n  /**\n   * Close connection pool\n   */\n  async close(): Promise<void> {\n    await this.pool.end();\n  }\n}\n","/**\n * Memory Service - High-level interface for memory operations\n * Implements mem0-style API with WAI SDK enhancements\n */\n\nimport {\n  MemoryConfig,\n  MemoryStorage,\n  MemoryEntry,\n  MemorySearchResult,\n  MemoryUpdate,\n  MemoryStats,\n  MemoryType,\n  EmbeddingProvider,\n  VectorStore,\n} from './types';\nimport { OpenAIEmbeddingProvider } from './embedding-provider';\nimport { PgVectorStore, InMemoryVectorStore } from './vector-store';\nimport { PgMemoryStorage } from './memory-storage';\n\n/**\n * Memory Service\n */\nexport class MemoryService {\n  private storage: MemoryStorage;\n  private cleanupInterval?: NodeJS.Timeout;\n\n  constructor(storage: MemoryStorage, config?: MemoryConfig) {\n    this.storage = storage;\n\n    // Setup auto-cleanup if enabled\n    if (config?.storage?.enableAutoCleanup) {\n      const intervalMs = config.storage.cleanupIntervalMs || 3600000; // 1 hour default\n      this.cleanupInterval = setInterval(() => {\n        this.cleanup().catch(console.error);\n      }, intervalMs);\n    }\n  }\n\n  /**\n   * Add memory from messages (mem0-style API)\n   */\n  async add(\n    messages: Array<{ role: string; content: string }> | string,\n    options: {\n      userId?: string;\n      sessionId?: string;\n      agentId?: string;\n      type?: MemoryType;\n      metadata?: Record<string, any>;\n      tags?: string[];\n      priority?: number;\n      ttl?: number;\n    } = {}\n  ): Promise<MemoryEntry> {\n    // Extract content from messages\n    let content: string;\n    if (typeof messages === 'string') {\n      content = messages;\n    } else {\n      content = messages.map(m => `${m.role}: ${m.content}`).join('\\n');\n    }\n\n    return this.storage.add({\n      type: options.type || 'user',\n      content,\n      userId: options.userId,\n      sessionId: options.sessionId,\n      agentId: options.agentId,\n      metadata: options.metadata,\n      tags: options.tags,\n      priority: options.priority,\n      ttl: options.ttl,\n    });\n  }\n\n  /**\n   * Search memories (mem0-style API)\n   */\n  async search(\n    query: string,\n    options: {\n      userId?: string;\n      sessionId?: string;\n      agentId?: string;\n      type?: MemoryType;\n      tags?: string[];\n      limit?: number;\n      minSimilarity?: number;\n    } = {}\n  ): Promise<MemorySearchResult[]> {\n    return this.storage.search({\n      query,\n      userId: options.userId,\n      sessionId: options.sessionId,\n      agentId: options.agentId,\n      type: options.type,\n      tags: options.tags,\n      limit: options.limit || 10,\n      minSimilarity: options.minSimilarity || 0.5,\n    });\n  }\n\n  /**\n   * Get memory by ID\n   */\n  async get(id: string): Promise<MemoryEntry | null> {\n    return this.storage.get(id);\n  }\n\n  /**\n   * Get all memories with filters (mem0-style API)\n   */\n  async getAll(filters?: {\n    userId?: string;\n    sessionId?: string;\n    agentId?: string;\n    type?: MemoryType;\n  }): Promise<MemoryEntry[]> {\n    return this.storage.getAll(filters);\n  }\n\n  /**\n   * Update memory (mem0-style API)\n   */\n  async update(id: string, updates: MemoryUpdate): Promise<MemoryEntry> {\n    return this.storage.update(id, updates);\n  }\n\n  /**\n   * Delete memory (mem0-style API)\n   */\n  async delete(id: string): Promise<boolean> {\n    return this.storage.delete(id);\n  }\n\n  /**\n   * Cleanup expired memories\n   */\n  async cleanup(): Promise<number> {\n    return this.storage.cleanup();\n  }\n\n  /**\n   * Get statistics\n   */\n  async getStats(): Promise<MemoryStats> {\n    return this.storage.getStats();\n  }\n\n  /**\n   * Close service and cleanup\n   */\n  async close(): Promise<void> {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n    }\n  }\n}\n\n/**\n * Create memory service from configuration\n */\nexport async function createMemoryService(config: MemoryConfig): Promise<MemoryService> {\n  // Create embedding provider\n  let embeddingProvider: EmbeddingProvider;\n  if (config.embeddingProvider.type === 'openai') {\n    const apiKey = config.embeddingProvider.apiKey || process.env.OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error('OpenAI API key is required');\n    }\n    embeddingProvider = new OpenAIEmbeddingProvider(\n      apiKey,\n      config.embeddingProvider.model || 'text-embedding-3-small'\n    );\n  } else {\n    throw new Error(`Unsupported embedding provider: ${config.embeddingProvider.type}`);\n  }\n\n  // Create vector store\n  let vectorStore: VectorStore;\n  if (config.vectorStore.type === 'pgvector') {\n    const connectionString = config.vectorStore.connectionString || process.env.DATABASE_URL;\n    if (!connectionString) {\n      throw new Error('Database connection string is required for pgvector');\n    }\n    vectorStore = new PgVectorStore(\n      connectionString,\n      config.vectorStore.tableName || 'wai_memory_vectors',\n      config.vectorStore.dimension || embeddingProvider.getDimension()\n    );\n  } else {\n    vectorStore = new InMemoryVectorStore(\n      config.vectorStore.dimension || embeddingProvider.getDimension()\n    );\n  }\n\n  // Create storage\n  const connectionString = process.env.DATABASE_URL;\n  if (!connectionString) {\n    throw new Error('Database connection string is required');\n  }\n\n  const storage = new PgMemoryStorage(\n    connectionString,\n    vectorStore,\n    embeddingProvider,\n    config.storage?.tableName || 'wai_memories'\n  );\n\n  await storage.initialize();\n\n  return new MemoryService(storage, config);\n}\n","export const CAM_VERSION = '1.0.0';\n","/**\n * WAI SDK Memory Package\n * mem0-style memory with pgvector and OpenAI embeddings\n */\n\n// Core types\nexport * from './core/types';\n\n// Embedding provider\nexport * from './core/embedding-provider';\n\n// Vector store\nexport * from './core/vector-store';\n\n// Memory storage\nexport * from './core/memory-storage';\n\n// Memory service (main API)\nexport * from './core/memory-service';\n\n// CAM 2.0 Monitoring (incubator integration)\nexport * from './cam';\n\n// Version\nexport const WAI_MEMORY_VERSION = '1.0.0';\n"]}